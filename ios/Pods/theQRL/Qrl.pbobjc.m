// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: qrl.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Qrl.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - QrlRoot

@implementation QrlRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - QrlRoot_FileDescriptor

static GPBFileDescriptor *QrlRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"qrl"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Empty

@implementation Empty


typedef struct Empty__storage_ {
  uint32_t _has_storage_[1];
} Empty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Empty class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Empty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodeStateReq

@implementation GetNodeStateReq


typedef struct GetNodeStateReq__storage_ {
  uint32_t _has_storage_[1];
} GetNodeStateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodeStateReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetNodeStateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodeStateResp

@implementation GetNodeStateResp

@dynamic hasInfo, info;

typedef struct GetNodeStateResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *info;
} GetNodeStateResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "info",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetNodeStateResp_FieldNumber_Info,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetNodeStateResp__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodeStateResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNodeStateResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetKnownPeersReq

@implementation GetKnownPeersReq


typedef struct GetKnownPeersReq__storage_ {
  uint32_t _has_storage_[1];
} GetKnownPeersReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetKnownPeersReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetKnownPeersReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetKnownPeersResp

@implementation GetKnownPeersResp

@dynamic hasNodeInfo, nodeInfo;
@dynamic knownPeersArray, knownPeersArray_Count;

typedef struct GetKnownPeersResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *nodeInfo;
  NSMutableArray *knownPeersArray;
} GetKnownPeersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetKnownPeersResp_FieldNumber_NodeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetKnownPeersResp__storage_, nodeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "knownPeersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = GetKnownPeersResp_FieldNumber_KnownPeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetKnownPeersResp__storage_, knownPeersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetKnownPeersResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetKnownPeersResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeersStatReq

@implementation GetPeersStatReq


typedef struct GetPeersStatReq__storage_ {
  uint32_t _has_storage_[1];
} GetPeersStatReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeersStatReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetPeersStatReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeersStatResp

@implementation GetPeersStatResp

@dynamic peersStatArray, peersStatArray_Count;

typedef struct GetPeersStatResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersStatArray;
} GetPeersStatResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersStatArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerStat),
        .number = GetPeersStatResp_FieldNumber_PeersStatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPeersStatResp__storage_, peersStatArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeersStatResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeersStatResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockReq

@implementation GetBlockReq

@dynamic queryOneOfCase;
@dynamic index;
@dynamic afterHash;

typedef struct GetBlockReq__storage_ {
  uint32_t _has_storage_[2];
  NSData *afterHash;
  uint64_t index;
} GetBlockReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockReq_FieldNumber_Index,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockReq__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "afterHash",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockReq_FieldNumber_AfterHash,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetBlockReq__storage_, afterHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "query",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetBlockReq_ClearQueryOneOfCase(GetBlockReq *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GetBlockResp

@implementation GetBlockResp

@dynamic hasNodeInfo, nodeInfo;
@dynamic hasBlock, block;

typedef struct GetBlockResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *nodeInfo;
  Block *block;
} GetBlockResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetBlockResp_FieldNumber_NodeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockResp__storage_, nodeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = GetBlockResp_FieldNumber_Block,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetBlockResp__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetStatsReq

@implementation GetStatsReq

@dynamic includeTimeseries;

typedef struct GetStatsReq__storage_ {
  uint32_t _has_storage_[1];
} GetStatsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "includeTimeseries",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsReq_FieldNumber_IncludeTimeseries,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetStatsReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetStatsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetStatsResp

@implementation GetStatsResp

@dynamic hasNodeInfo, nodeInfo;
@dynamic epoch;
@dynamic uptimeNetwork;
@dynamic blockLastReward;
@dynamic blockTimeMean;
@dynamic blockTimeSd;
@dynamic coinsTotalSupply;
@dynamic coinsEmitted;
@dynamic blockTimeseriesArray, blockTimeseriesArray_Count;

typedef struct GetStatsResp__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo *nodeInfo;
  NSMutableArray *blockTimeseriesArray;
  uint64_t epoch;
  uint64_t uptimeNetwork;
  uint64_t blockLastReward;
  uint64_t blockTimeMean;
  uint64_t blockTimeSd;
  uint64_t coinsTotalSupply;
  uint64_t coinsEmitted;
} GetStatsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo),
        .number = GetStatsResp_FieldNumber_NodeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, nodeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "epoch",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_Epoch,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, epoch),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "uptimeNetwork",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_UptimeNetwork,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, uptimeNetwork),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockLastReward",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_BlockLastReward,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockLastReward),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimeMean",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_BlockTimeMean,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockTimeMean),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimeSd",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_BlockTimeSd,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockTimeSd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "coinsTotalSupply",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_CoinsTotalSupply,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, coinsTotalSupply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "coinsEmitted",
        .dataTypeSpecific.className = NULL,
        .number = GetStatsResp_FieldNumber_CoinsEmitted,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, coinsEmitted),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockTimeseriesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockDataPoint),
        .number = GetStatsResp_FieldNumber_BlockTimeseriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetStatsResp__storage_, blockTimeseriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetStatsResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetStatsResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressFromPKReq

@implementation GetAddressFromPKReq

@dynamic pk;

typedef struct GetAddressFromPKReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *pk;
} GetAddressFromPKReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pk",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressFromPKReq_FieldNumber_Pk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressFromPKReq__storage_, pk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressFromPKReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressFromPKReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressFromPKResp

@implementation GetAddressFromPKResp

@dynamic address;

typedef struct GetAddressFromPKResp__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} GetAddressFromPKResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressFromPKResp_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressFromPKResp__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressFromPKResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressFromPKResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockDataPoint

@implementation BlockDataPoint

@dynamic number;
@dynamic difficulty;
@dynamic timestamp;
@dynamic timeLast;
@dynamic timeMovavg;
@dynamic hashPower;
@dynamic headerHash;
@dynamic headerHashPrev;

typedef struct BlockDataPoint__storage_ {
  uint32_t _has_storage_[1];
  float hashPower;
  NSString *difficulty;
  NSData *headerHash;
  NSData *headerHashPrev;
  uint64_t number;
  uint64_t timestamp;
  uint64_t timeLast;
  uint64_t timeMovavg;
} BlockDataPoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_Number,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "difficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_Difficulty,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, difficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timeLast",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_TimeLast,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, timeLast),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timeMovavg",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_TimeMovavg,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, timeMovavg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "hashPower",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_HashPower,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, hashPower),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "headerHash",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_HeaderHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, headerHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "headerHashPrev",
        .dataTypeSpecific.className = NULL,
        .number = BlockDataPoint_FieldNumber_HeaderHashPrev,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BlockDataPoint__storage_, headerHashPrev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockDataPoint class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockDataPoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressStateReq

@implementation GetAddressStateReq

@dynamic address;

typedef struct GetAddressStateReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
} GetAddressStateReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressStateReq_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressStateReq__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressStateReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressStateReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressStateResp

@implementation GetAddressStateResp

@dynamic hasState, state;

typedef struct GetAddressStateResp__storage_ {
  uint32_t _has_storage_[1];
  AddressState *state;
} GetAddressStateResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressState),
        .number = GetAddressStateResp_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressStateResp__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressStateResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressStateResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetObjectReq

@implementation GetObjectReq

@dynamic query;

typedef struct GetObjectReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *query;
} GetObjectReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetObjectReq_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetObjectReq__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetObjectReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetObjectReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetObjectResp

@implementation GetObjectResp

@dynamic resultOneOfCase;
@dynamic found;
@dynamic addressState;
@dynamic transaction;
@dynamic blockExtended;

typedef struct GetObjectResp__storage_ {
  uint32_t _has_storage_[2];
  AddressState *addressState;
  TransactionExtended *transaction;
  BlockExtended *blockExtended;
} GetObjectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "found",
        .dataTypeSpecific.className = NULL,
        .number = GetObjectResp_FieldNumber_Found,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "addressState",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressState),
        .number = GetObjectResp_FieldNumber_AddressState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetObjectResp__storage_, addressState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = GetObjectResp_FieldNumber_Transaction,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetObjectResp__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockExtended",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockExtended),
        .number = GetObjectResp_FieldNumber_BlockExtended,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetObjectResp__storage_, blockExtended),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetObjectResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetObjectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "result",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetObjectResp_ClearResultOneOfCase(GetObjectResp *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GetLatestDataReq

@implementation GetLatestDataReq

@dynamic filter;
@dynamic offset;
@dynamic quantity;

typedef struct GetLatestDataReq__storage_ {
  uint32_t _has_storage_[1];
  GetLatestDataReq_Filter filter;
  uint32_t offset;
  uint32_t quantity;
} GetLatestDataReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "filter",
        .dataTypeSpecific.enumDescFunc = GetLatestDataReq_Filter_EnumDescriptor,
        .number = GetLatestDataReq_FieldNumber_Filter,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLatestDataReq__storage_, filter),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = GetLatestDataReq_FieldNumber_Offset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLatestDataReq__storage_, offset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = GetLatestDataReq_FieldNumber_Quantity,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLatestDataReq__storage_, quantity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLatestDataReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLatestDataReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GetLatestDataReq_Filter_RawValue(GetLatestDataReq *message) {
  GPBDescriptor *descriptor = [GetLatestDataReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetLatestDataReq_FieldNumber_Filter];
  return GPBGetMessageInt32Field(message, field);
}

void SetGetLatestDataReq_Filter_RawValue(GetLatestDataReq *message, int32_t value) {
  GPBDescriptor *descriptor = [GetLatestDataReq descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GetLatestDataReq_FieldNumber_Filter];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GetLatestDataReq_Filter

GPBEnumDescriptor *GetLatestDataReq_Filter_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "All\000Blockheaders\000Transactions\000Transactio"
        "nsUnconfirmed\000";
    static const int32_t values[] = {
        GetLatestDataReq_Filter_All,
        GetLatestDataReq_Filter_Blockheaders,
        GetLatestDataReq_Filter_Transactions,
        GetLatestDataReq_Filter_TransactionsUnconfirmed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GetLatestDataReq_Filter)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GetLatestDataReq_Filter_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GetLatestDataReq_Filter_IsValidValue(int32_t value__) {
  switch (value__) {
    case GetLatestDataReq_Filter_All:
    case GetLatestDataReq_Filter_Blockheaders:
    case GetLatestDataReq_Filter_Transactions:
    case GetLatestDataReq_Filter_TransactionsUnconfirmed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetLatestDataResp

@implementation GetLatestDataResp

@dynamic blockheadersArray, blockheadersArray_Count;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic transactionsUnconfirmedArray, transactionsUnconfirmedArray_Count;

typedef struct GetLatestDataResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockheadersArray;
  NSMutableArray *transactionsArray;
  NSMutableArray *transactionsUnconfirmedArray;
} GetLatestDataResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockheadersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeaderExtended),
        .number = GetLatestDataResp_FieldNumber_BlockheadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatestDataResp__storage_, blockheadersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = GetLatestDataResp_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatestDataResp__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsUnconfirmedArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = GetLatestDataResp_FieldNumber_TransactionsUnconfirmedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLatestDataResp__storage_, transactionsUnconfirmedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLatestDataResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLatestDataResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferCoinsReq

@implementation TransferCoinsReq

@dynamic masterAddr;
@dynamic addressesToArray, addressesToArray_Count;
@dynamic amountsArray, amountsArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct TransferCoinsReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSMutableArray *addressesToArray;
  GPBUInt64Array *amountsArray;
  NSData *xmssPk;
  uint64_t fee;
} TransferCoinsReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addressesToArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_AddressesToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, addressesToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = TransferCoinsReq_FieldNumber_XmssPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferCoinsReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferCoinsReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferCoinsReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferCoinsResp

@implementation TransferCoinsResp

@dynamic hasExtendedTransactionUnsigned, extendedTransactionUnsigned;

typedef struct TransferCoinsResp__storage_ {
  uint32_t _has_storage_[1];
  TransactionExtended *extendedTransactionUnsigned;
} TransferCoinsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "extendedTransactionUnsigned",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = TransferCoinsResp_FieldNumber_ExtendedTransactionUnsigned,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferCoinsResp__storage_, extendedTransactionUnsigned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferCoinsResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferCoinsResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushTransactionReq

@implementation PushTransactionReq

@dynamic hasTransactionSigned, transactionSigned;

typedef struct PushTransactionReq__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transactionSigned;
} PushTransactionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionSigned",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = PushTransactionReq_FieldNumber_TransactionSigned,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushTransactionReq__storage_, transactionSigned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushTransactionReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushTransactionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushTransactionResp

@implementation PushTransactionResp

@dynamic errorCode;
@dynamic errorDescription;
@dynamic txHash;

typedef struct PushTransactionResp__storage_ {
  uint32_t _has_storage_[1];
  PushTransactionResp_ResponseCode errorCode;
  NSString *errorDescription;
  NSData *txHash;
} PushTransactionResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = PushTransactionResp_ResponseCode_EnumDescriptor,
        .number = PushTransactionResp_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushTransactionResp__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "errorDescription",
        .dataTypeSpecific.className = NULL,
        .number = PushTransactionResp_FieldNumber_ErrorDescription,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushTransactionResp__storage_, errorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = PushTransactionResp_FieldNumber_TxHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushTransactionResp__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushTransactionResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushTransactionResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PushTransactionResp_ErrorCode_RawValue(PushTransactionResp *message) {
  GPBDescriptor *descriptor = [PushTransactionResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PushTransactionResp_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetPushTransactionResp_ErrorCode_RawValue(PushTransactionResp *message, int32_t value) {
  GPBDescriptor *descriptor = [PushTransactionResp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PushTransactionResp_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum PushTransactionResp_ResponseCode

GPBEnumDescriptor *PushTransactionResp_ResponseCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Error\000ValidationFailed\000Submitted"
        "\000";
    static const int32_t values[] = {
        PushTransactionResp_ResponseCode_Unknown,
        PushTransactionResp_ResponseCode_Error,
        PushTransactionResp_ResponseCode_ValidationFailed,
        PushTransactionResp_ResponseCode_Submitted,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PushTransactionResp_ResponseCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PushTransactionResp_ResponseCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PushTransactionResp_ResponseCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case PushTransactionResp_ResponseCode_Unknown:
    case PushTransactionResp_ResponseCode_Error:
    case PushTransactionResp_ResponseCode_ValidationFailed:
    case PushTransactionResp_ResponseCode_Submitted:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageTxnReq

@implementation MessageTxnReq

@dynamic masterAddr;
@dynamic message;
@dynamic fee;
@dynamic xmssPk;

typedef struct MessageTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *message;
  NSData *xmssPk;
  uint64_t fee;
} MessageTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = MessageTxnReq_FieldNumber_XmssPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenTxnReq

@implementation TokenTxnReq

@dynamic masterAddr;
@dynamic symbol;
@dynamic name;
@dynamic owner;
@dynamic decimals;
@dynamic initialBalancesArray, initialBalancesArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct TokenTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *symbol;
  NSData *name;
  NSData *owner;
  NSMutableArray *initialBalancesArray;
  NSData *xmssPk;
  uint64_t decimals;
  uint64_t fee;
} TokenTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Symbol,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Owner,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Decimals,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, decimals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "initialBalancesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressAmount),
        .number = TokenTxnReq_FieldNumber_InitialBalancesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, initialBalancesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_Fee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = TokenTxnReq_FieldNumber_XmssPk,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TokenTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferTokenTxnReq

@implementation TransferTokenTxnReq

@dynamic masterAddr;
@dynamic addressesToArray, addressesToArray_Count;
@dynamic tokenTxhash;
@dynamic amountsArray, amountsArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct TransferTokenTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSMutableArray *addressesToArray;
  NSData *tokenTxhash;
  GPBUInt64Array *amountsArray;
  NSData *xmssPk;
  uint64_t fee;
} TransferTokenTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addressesToArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_AddressesToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, addressesToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_TokenTxhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = TransferTokenTxnReq_FieldNumber_XmssPk,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferTokenTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferTokenTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferTokenTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SlaveTxnReq

@implementation SlaveTxnReq

@dynamic masterAddr;
@dynamic slavePksArray, slavePksArray_Count;
@dynamic accessTypesArray, accessTypesArray_Count;
@dynamic fee;
@dynamic xmssPk;

typedef struct SlaveTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSMutableArray *slavePksArray;
  GPBUInt32Array *accessTypesArray;
  NSData *xmssPk;
  uint64_t fee;
} SlaveTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "slavePksArray",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_SlavePksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, slavePksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accessTypesArray",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_AccessTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, accessTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = SlaveTxnReq_FieldNumber_XmssPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SlaveTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SlaveTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SlaveTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticePublicKeyTxnReq

@implementation LatticePublicKeyTxnReq

@dynamic masterAddr;
@dynamic kyberPk;
@dynamic dilithiumPk;
@dynamic fee;
@dynamic xmssPk;

typedef struct LatticePublicKeyTxnReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *masterAddr;
  NSData *kyberPk;
  NSData *dilithiumPk;
  NSData *xmssPk;
  uint64_t fee;
} LatticePublicKeyTxnReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = LatticePublicKeyTxnReq_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LatticePublicKeyTxnReq__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "kyberPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePublicKeyTxnReq_FieldNumber_KyberPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LatticePublicKeyTxnReq__storage_, kyberPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dilithiumPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePublicKeyTxnReq_FieldNumber_DilithiumPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LatticePublicKeyTxnReq__storage_, dilithiumPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = LatticePublicKeyTxnReq_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LatticePublicKeyTxnReq__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "xmssPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePublicKeyTxnReq_FieldNumber_XmssPk,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LatticePublicKeyTxnReq__storage_, xmssPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticePublicKeyTxnReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticePublicKeyTxnReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLocalAddressesReq

@implementation GetLocalAddressesReq


typedef struct GetLocalAddressesReq__storage_ {
  uint32_t _has_storage_[1];
} GetLocalAddressesReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLocalAddressesReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetLocalAddressesReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLocalAddressesResp

@implementation GetLocalAddressesResp

@dynamic addressesArray, addressesArray_Count;

typedef struct GetLocalAddressesResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} GetLocalAddressesResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = GetLocalAddressesResp_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLocalAddressesResp__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLocalAddressesResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLocalAddressesResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo

@implementation NodeInfo

@dynamic version;
@dynamic state;
@dynamic numConnections;
@dynamic numKnownPeers;
@dynamic uptime;
@dynamic blockHeight;
@dynamic blockLastHash;
@dynamic networkId;

typedef struct NodeInfo__storage_ {
  uint32_t _has_storage_[1];
  NodeInfo_State state;
  uint32_t numConnections;
  uint32_t numKnownPeers;
  NSString *version;
  NSData *blockLastHash;
  NSString *networkId;
  uint64_t uptime;
  uint64_t blockHeight;
} NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = NodeInfo_State_EnumDescriptor,
        .number = NodeInfo_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "numConnections",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NumConnections,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, numConnections),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "numKnownPeers",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NumKnownPeers,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, numKnownPeers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uptime",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_Uptime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, uptime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_BlockHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockLastHash",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_BlockLastHash,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, blockLastHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "networkId",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_NetworkId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, networkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NodeInfo_State_RawValue(NodeInfo *message) {
  GPBDescriptor *descriptor = [NodeInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NodeInfo_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetNodeInfo_State_RawValue(NodeInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [NodeInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NodeInfo_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum NodeInfo_State

GPBEnumDescriptor *NodeInfo_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Unsynced\000Syncing\000Synced\000Forked\000";
    static const int32_t values[] = {
        NodeInfo_State_Unknown,
        NodeInfo_State_Unsynced,
        NodeInfo_State_Syncing,
        NodeInfo_State_Synced,
        NodeInfo_State_Forked,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NodeInfo_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NodeInfo_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NodeInfo_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case NodeInfo_State_Unknown:
    case NodeInfo_State_Unsynced:
    case NodeInfo_State_Syncing:
    case NodeInfo_State_Synced:
    case NodeInfo_State_Forked:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - StoredPeers

@implementation StoredPeers

@dynamic peersArray, peersArray_Count;

typedef struct StoredPeers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} StoredPeers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Peer),
        .number = StoredPeers_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StoredPeers__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StoredPeers class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StoredPeers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peer

@implementation Peer

@dynamic ip;

typedef struct Peer__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
} Peer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = Peer_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Peer__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peer class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressState

@implementation AddressState

@dynamic address;
@dynamic balance;
@dynamic nonce;
@dynamic otsBitfieldArray, otsBitfieldArray_Count;
@dynamic transactionHashesArray, transactionHashesArray_Count;
@dynamic tokens, tokens_Count;
@dynamic latticePkListArray, latticePkListArray_Count;
@dynamic slavePksAccessType, slavePksAccessType_Count;
@dynamic otsCounter;

typedef struct AddressState__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *otsBitfieldArray;
  NSMutableArray *transactionHashesArray;
  GPBStringUInt64Dictionary *tokens;
  NSMutableArray *latticePkListArray;
  GPBStringUInt32Dictionary *slavePksAccessType;
  uint64_t balance;
  uint64_t nonce;
  uint64_t otsCounter;
} AddressState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressState__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressState__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Nonce,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddressState__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "otsBitfieldArray",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_OtsBitfieldArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, otsBitfieldArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transactionHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_TransactionHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, transactionHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tokens",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_Tokens,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, tokens),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "latticePkListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LatticePK),
        .number = AddressState_FieldNumber_LatticePkListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, latticePkListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slavePksAccessType",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_SlavePksAccessType,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressState__storage_, slavePksAccessType),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "otsCounter",
        .dataTypeSpecific.className = NULL,
        .number = AddressState_FieldNumber_OtsCounter,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddressState__storage_, otsCounter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressState class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\000latticePK_list\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticePK

@implementation LatticePK

@dynamic txhash;
@dynamic dilithiumPk;
@dynamic kyberPk;

typedef struct LatticePK__storage_ {
  uint32_t _has_storage_[1];
  NSData *txhash;
  NSData *dilithiumPk;
  NSData *kyberPk;
} LatticePK__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txhash",
        .dataTypeSpecific.className = NULL,
        .number = LatticePK_FieldNumber_Txhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LatticePK__storage_, txhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dilithiumPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePK_FieldNumber_DilithiumPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LatticePK__storage_, dilithiumPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "kyberPk",
        .dataTypeSpecific.className = NULL,
        .number = LatticePK_FieldNumber_KyberPk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LatticePK__storage_, kyberPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticePK class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticePK__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressAmount

@implementation AddressAmount

@dynamic address;
@dynamic amount;

typedef struct AddressAmount__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t amount;
} AddressAmount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressAmount_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressAmount__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = AddressAmount_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressAmount__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressAmount class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressAmount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader

@implementation BlockHeader

@dynamic hashHeader;
@dynamic blockNumber;
@dynamic timestampSeconds;
@dynamic hashHeaderPrev;
@dynamic rewardBlock;
@dynamic rewardFee;
@dynamic merkleRoot;
@dynamic miningNonce;
@dynamic extraNonce;

typedef struct BlockHeader__storage_ {
  uint32_t _has_storage_[1];
  uint32_t miningNonce;
  NSData *hashHeader;
  NSData *hashHeaderPrev;
  NSData *merkleRoot;
  uint64_t blockNumber;
  uint64_t timestampSeconds;
  uint64_t rewardBlock;
  uint64_t rewardFee;
  uint64_t extraNonce;
} BlockHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashHeader",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_HashHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, hashHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_BlockNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "timestampSeconds",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_TimestampSeconds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, timestampSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "hashHeaderPrev",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_HashHeaderPrev,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, hashHeaderPrev),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rewardBlock",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_RewardBlock,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rewardBlock),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "rewardFee",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_RewardFee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rewardFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "merkleRoot",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_MerkleRoot,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, merkleRoot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "miningNonce",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_MiningNonce,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, miningNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extraNonce",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_ExtraNonce,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, extraNonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeaderExtended

@implementation BlockHeaderExtended

@dynamic hasHeader, header;
@dynamic hasTransactionCount, transactionCount;

typedef struct BlockHeaderExtended__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  TransactionCount *transactionCount;
} BlockHeaderExtended__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = BlockHeaderExtended_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeaderExtended__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionCount",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionCount),
        .number = BlockHeaderExtended_FieldNumber_TransactionCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeaderExtended__storage_, transactionCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeaderExtended class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeaderExtended__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionCount

@implementation TransactionCount

@dynamic count, count_Count;

typedef struct TransactionCount__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32UInt32Dictionary *count;
} TransactionCount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = TransactionCount_FieldNumber_Count,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionCount__storage_, count),
        .flags = GPBFieldMapKeyUInt32,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionCount class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionCount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionExtended

@implementation TransactionExtended

@dynamic hasHeader, header;
@dynamic hasTx, tx;
@dynamic addrFrom;
@dynamic size;

typedef struct TransactionExtended__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  Transaction *tx;
  NSData *addrFrom;
  uint64_t size;
} TransactionExtended__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = TransactionExtended_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tx",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionExtended_FieldNumber_Tx,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, tx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = TransactionExtended_FieldNumber_AddrFrom,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = TransactionExtended_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransactionExtended__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionExtended class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionExtended__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockExtended

@implementation BlockExtended

@dynamic hasHeader, header;
@dynamic extendedTransactionsArray, extendedTransactionsArray_Count;
@dynamic genesisBalanceArray, genesisBalanceArray_Count;
@dynamic size;

typedef struct BlockExtended__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  NSMutableArray *extendedTransactionsArray;
  NSMutableArray *genesisBalanceArray;
  uint64_t size;
} BlockExtended__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = BlockExtended_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extendedTransactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionExtended),
        .number = BlockExtended_FieldNumber_ExtendedTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, extendedTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "genesisBalanceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GenesisBalance),
        .number = BlockExtended_FieldNumber_GenesisBalanceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, genesisBalanceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = BlockExtended_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockExtended__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockExtended class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockExtended__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic hasHeader, header;
@dynamic transactionsArray, transactionsArray_Count;
@dynamic genesisBalanceArray, genesisBalanceArray_Count;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader *header;
  NSMutableArray *transactionsArray;
  NSMutableArray *genesisBalanceArray;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Block_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Block_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "genesisBalanceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GenesisBalance),
        .number = Block_FieldNumber_GenesisBalanceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, genesisBalanceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenesisBalance

@implementation GenesisBalance

@dynamic address;
@dynamic balance;

typedef struct GenesisBalance__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  uint64_t balance;
} GenesisBalance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GenesisBalance_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenesisBalance__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = GenesisBalance_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenesisBalance__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenesisBalance class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenesisBalance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockMetaDataList

@implementation BlockMetaDataList

@dynamic blockNumberHashesArray, blockNumberHashesArray_Count;

typedef struct BlockMetaDataList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blockNumberHashesArray;
} BlockMetaDataList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumberHashesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockMetaData),
        .number = BlockMetaDataList_FieldNumber_BlockNumberHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockMetaDataList__storage_, blockNumberHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockMetaDataList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockMetaDataList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic transactionTypeOneOfCase;
@dynamic masterAddr;
@dynamic fee;
@dynamic publicKey;
@dynamic signature;
@dynamic nonce;
@dynamic transactionHash;
@dynamic transfer;
@dynamic coinbase;
@dynamic latticePk;
@dynamic message;
@dynamic token;
@dynamic transferToken;
@dynamic slave;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[2];
  NSData *masterAddr;
  NSData *publicKey;
  NSData *signature;
  NSData *transactionHash;
  Transaction_Transfer *transfer;
  Transaction_CoinBase *coinbase;
  Transaction_LatticePublicKey *latticePk;
  Transaction_Message *message;
  Transaction_Token *token;
  Transaction_TransferToken *transferToken;
  Transaction_Slave *slave;
  uint64_t fee;
  uint64_t nonce;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "masterAddr",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_MasterAddr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, masterAddr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_PublicKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Signature,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Nonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "transactionHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TransactionHash,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, transactionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transfer",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Transfer),
        .number = Transaction_FieldNumber_Transfer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, transfer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coinbase",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_CoinBase),
        .number = Transaction_FieldNumber_Coinbase,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, coinbase),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latticePk",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_LatticePublicKey),
        .number = Transaction_FieldNumber_LatticePk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, latticePk),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Message),
        .number = Transaction_FieldNumber_Message,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Token),
        .number = Transaction_FieldNumber_Token,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transferToken",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_TransferToken),
        .number = Transaction_FieldNumber_TransferToken,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, transferToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slave",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Slave),
        .number = Transaction_FieldNumber_Slave,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Transaction__storage_, slave),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "transactionType",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void Transaction_ClearTransactionTypeOneOfCase(Transaction *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Transaction_Transfer

@implementation Transaction_Transfer

@dynamic addrsToArray, addrsToArray_Count;
@dynamic amountsArray, amountsArray_Count;

typedef struct Transaction_Transfer__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addrsToArray;
  GPBUInt64Array *amountsArray;
} Transaction_Transfer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrsToArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Transfer_FieldNumber_AddrsToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Transfer__storage_, addrsToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Transfer_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Transfer__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Transfer class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Transfer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_CoinBase

@implementation Transaction_CoinBase

@dynamic addrTo;
@dynamic amount;

typedef struct Transaction_CoinBase__storage_ {
  uint32_t _has_storage_[1];
  NSData *addrTo;
  uint64_t amount;
} Transaction_CoinBase__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrTo",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_CoinBase_FieldNumber_AddrTo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_CoinBase__storage_, addrTo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_CoinBase_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_CoinBase__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_CoinBase class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_CoinBase__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_LatticePublicKey

@implementation Transaction_LatticePublicKey

@dynamic kyberPk;
@dynamic dilithiumPk;

typedef struct Transaction_LatticePublicKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *kyberPk;
  NSData *dilithiumPk;
} Transaction_LatticePublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "kyberPk",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_LatticePublicKey_FieldNumber_KyberPk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_LatticePublicKey__storage_, kyberPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dilithiumPk",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_LatticePublicKey_FieldNumber_DilithiumPk,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_LatticePublicKey__storage_, dilithiumPk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_LatticePublicKey class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_LatticePublicKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Message

@implementation Transaction_Message

@dynamic messageHash;

typedef struct Transaction_Message__storage_ {
  uint32_t _has_storage_[1];
  NSData *messageHash;
} Transaction_Message__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Message_FieldNumber_MessageHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Message__storage_, messageHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Message class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Message__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Token

@implementation Transaction_Token

@dynamic symbol;
@dynamic name;
@dynamic owner;
@dynamic decimals;
@dynamic initialBalancesArray, initialBalancesArray_Count;

typedef struct Transaction_Token__storage_ {
  uint32_t _has_storage_[1];
  NSData *symbol;
  NSData *name;
  NSData *owner;
  NSMutableArray *initialBalancesArray;
  uint64_t decimals;
} Transaction_Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "symbol",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Symbol,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, symbol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "owner",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Owner,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, owner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "decimals",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Token_FieldNumber_Decimals,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, decimals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "initialBalancesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressAmount),
        .number = Transaction_Token_FieldNumber_InitialBalancesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Token__storage_, initialBalancesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Token class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Token__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_TransferToken

@implementation Transaction_TransferToken

@dynamic tokenTxhash;
@dynamic addrsToArray, addrsToArray_Count;
@dynamic amountsArray, amountsArray_Count;

typedef struct Transaction_TransferToken__storage_ {
  uint32_t _has_storage_[1];
  NSData *tokenTxhash;
  NSMutableArray *addrsToArray;
  GPBUInt64Array *amountsArray;
} Transaction_TransferToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_TransferToken_FieldNumber_TokenTxhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_TransferToken__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrsToArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_TransferToken_FieldNumber_AddrsToArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_TransferToken__storage_, addrsToArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "amountsArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_TransferToken_FieldNumber_AmountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_TransferToken__storage_, amountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_TransferToken class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_TransferToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Slave

@implementation Transaction_Slave

@dynamic slavePksArray, slavePksArray_Count;
@dynamic accessTypesArray, accessTypesArray_Count;

typedef struct Transaction_Slave__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *slavePksArray;
  GPBUInt32Array *accessTypesArray;
} Transaction_Slave__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "slavePksArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Slave_FieldNumber_SlavePksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Slave__storage_, slavePksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accessTypesArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Slave_FieldNumber_AccessTypesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_Slave__storage_, accessTypesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Slave class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Slave__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenList

@implementation TokenList

@dynamic tokenTxhashArray, tokenTxhashArray_Count;

typedef struct TokenList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *tokenTxhashArray;
} TokenList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhashArray",
        .dataTypeSpecific.className = NULL,
        .number = TokenList_FieldNumber_TokenTxhashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenList__storage_, tokenTxhashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TokenMetadata

@implementation TokenMetadata

@dynamic tokenTxhash;
@dynamic transferTokenTxHashesArray, transferTokenTxHashesArray_Count;

typedef struct TokenMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSData *tokenTxhash;
  NSMutableArray *transferTokenTxHashesArray;
} TokenMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tokenTxhash",
        .dataTypeSpecific.className = NULL,
        .number = TokenMetadata_FieldNumber_TokenTxhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TokenMetadata__storage_, tokenTxhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transferTokenTxHashesArray",
        .dataTypeSpecific.className = NULL,
        .number = TokenMetadata_FieldNumber_TransferTokenTxHashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TokenMetadata__storage_, transferTokenTxHashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenMetadata class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TokenMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectEphemeralMessageReq

@implementation CollectEphemeralMessageReq

@dynamic msgId;

typedef struct CollectEphemeralMessageReq__storage_ {
  uint32_t _has_storage_[1];
  NSData *msgId;
} CollectEphemeralMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = CollectEphemeralMessageReq_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectEphemeralMessageReq__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectEphemeralMessageReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectEphemeralMessageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CollectEphemeralMessageResp

@implementation CollectEphemeralMessageResp

@dynamic hasEphemeralMetadata, ephemeralMetadata;

typedef struct CollectEphemeralMessageResp__storage_ {
  uint32_t _has_storage_[1];
  EphemeralMetadata *ephemeralMetadata;
} CollectEphemeralMessageResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ephemeralMetadata",
        .dataTypeSpecific.className = GPBStringifySymbol(EphemeralMetadata),
        .number = CollectEphemeralMessageResp_FieldNumber_EphemeralMetadata,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectEphemeralMessageResp__storage_, ephemeralMetadata),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectEphemeralMessageResp class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectEphemeralMessageResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushEphemeralMessageReq

@implementation PushEphemeralMessageReq

@dynamic hasEphemeralMessage, ephemeralMessage;

typedef struct PushEphemeralMessageReq__storage_ {
  uint32_t _has_storage_[1];
  EncryptedEphemeralMessage *ephemeralMessage;
} PushEphemeralMessageReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ephemeralMessage",
        .dataTypeSpecific.className = GPBStringifySymbol(EncryptedEphemeralMessage),
        .number = PushEphemeralMessageReq_FieldNumber_EphemeralMessage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushEphemeralMessageReq__storage_, ephemeralMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushEphemeralMessageReq class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushEphemeralMessageReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedEphemeralMessage

@implementation EncryptedEphemeralMessage

@dynamic msgId;
@dynamic ttl;
@dynamic ttr;
@dynamic hasChannel, channel;
@dynamic nonce;
@dynamic payload;

typedef struct EncryptedEphemeralMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *msgId;
  EncryptedEphemeralMessage_Channel *channel;
  NSData *payload;
  uint64_t ttl;
  uint64_t ttr;
  uint64_t nonce;
} EncryptedEphemeralMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ttl",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Ttl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, ttl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ttr",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Ttr,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, ttr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(EncryptedEphemeralMessage_Channel),
        .number = EncryptedEphemeralMessage_FieldNumber_Channel,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonce",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Nonce,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, nonce),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_FieldNumber_Payload,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedEphemeralMessage class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedEphemeralMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedEphemeralMessage_Channel

@implementation EncryptedEphemeralMessage_Channel

@dynamic encAes256Symkey;

typedef struct EncryptedEphemeralMessage_Channel__storage_ {
  uint32_t _has_storage_[1];
  NSData *encAes256Symkey;
} EncryptedEphemeralMessage_Channel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encAes256Symkey",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedEphemeralMessage_Channel_FieldNumber_EncAes256Symkey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedEphemeralMessage_Channel__storage_, encAes256Symkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedEphemeralMessage_Channel class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedEphemeralMessage_Channel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(EncryptedEphemeralMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EphemeralChannelPayload

@implementation EphemeralChannelPayload

@dynamic prf512Seed;
@dynamic dilithiumSignature;
@dynamic addrFrom;
@dynamic data_p;

typedef struct EphemeralChannelPayload__storage_ {
  uint32_t _has_storage_[1];
  NSData *prf512Seed;
  NSData *dilithiumSignature;
  NSData *addrFrom;
  NSData *data_p;
} EphemeralChannelPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prf512Seed",
        .dataTypeSpecific.className = NULL,
        .number = EphemeralChannelPayload_FieldNumber_Prf512Seed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EphemeralChannelPayload__storage_, prf512Seed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dilithiumSignature",
        .dataTypeSpecific.className = NULL,
        .number = EphemeralChannelPayload_FieldNumber_DilithiumSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EphemeralChannelPayload__storage_, dilithiumSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = EphemeralChannelPayload_FieldNumber_AddrFrom,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EphemeralChannelPayload__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = EphemeralChannelPayload_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EphemeralChannelPayload__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EphemeralChannelPayload class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EphemeralChannelPayload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EphemeralMessagePayload

@implementation EphemeralMessagePayload

@dynamic addrFrom;
@dynamic data_p;

typedef struct EphemeralMessagePayload__storage_ {
  uint32_t _has_storage_[1];
  NSData *addrFrom;
  NSData *data_p;
} EphemeralMessagePayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addrFrom",
        .dataTypeSpecific.className = NULL,
        .number = EphemeralMessagePayload_FieldNumber_AddrFrom,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EphemeralMessagePayload__storage_, addrFrom),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = EphemeralMessagePayload_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EphemeralMessagePayload__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EphemeralMessagePayload class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EphemeralMessagePayload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LatticePublicKeys

@implementation LatticePublicKeys

@dynamic latticeKeysArray, latticeKeysArray_Count;

typedef struct LatticePublicKeys__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *latticeKeysArray;
} LatticePublicKeys__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latticeKeysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = LatticePublicKeys_FieldNumber_LatticeKeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LatticePublicKeys__storage_, latticeKeysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LatticePublicKeys class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LatticePublicKeys__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EphemeralMetadata

@implementation EphemeralMetadata

@dynamic encryptedEphemeralMessageListArray, encryptedEphemeralMessageListArray_Count;

typedef struct EphemeralMetadata__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *encryptedEphemeralMessageListArray;
} EphemeralMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encryptedEphemeralMessageListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EncryptedEphemeralMessage),
        .number = EphemeralMetadata_FieldNumber_EncryptedEphemeralMessageListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EphemeralMetadata__storage_, encryptedEphemeralMessageListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EphemeralMetadata class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EphemeralMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressList

@implementation AddressList

@dynamic addressesArray, addressesArray_Count;

typedef struct AddressList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} AddressList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = AddressList_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressList__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressList class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeightData

@implementation BlockHeightData

@dynamic blockNumber;
@dynamic blockHeaderhash;
@dynamic cumulativeDifficulty;

typedef struct BlockHeightData__storage_ {
  uint32_t _has_storage_[1];
  NSData *blockHeaderhash;
  NSData *cumulativeDifficulty;
  uint64_t blockNumber;
} BlockHeightData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeightData_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeightData__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "blockHeaderhash",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeightData_FieldNumber_BlockHeaderhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeightData__storage_, blockHeaderhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cumulativeDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeightData_FieldNumber_CumulativeDifficulty,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeightData__storage_, cumulativeDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeightData class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeightData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockMetaData

@implementation BlockMetaData

@dynamic isOrphan;
@dynamic blockDifficulty;
@dynamic cumulativeDifficulty;
@dynamic childHeaderhashesArray, childHeaderhashesArray_Count;
@dynamic lastNHeaderhashesArray, lastNHeaderhashesArray_Count;

typedef struct BlockMetaData__storage_ {
  uint32_t _has_storage_[1];
  NSData *blockDifficulty;
  NSData *cumulativeDifficulty;
  NSMutableArray *childHeaderhashesArray;
  NSMutableArray *lastNHeaderhashesArray;
} BlockMetaData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isOrphan",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_IsOrphan,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "blockDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_BlockDifficulty,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, blockDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cumulativeDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_CumulativeDifficulty,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, cumulativeDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "childHeaderhashesArray",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_ChildHeaderhashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, childHeaderhashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "lastNHeaderhashesArray",
        .dataTypeSpecific.className = NULL,
        .number = BlockMetaData_FieldNumber_LastNHeaderhashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockMetaData__storage_, lastNHeaderhashesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockMetaData class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockMetaData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\005\000last_N_headerhashes\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockNumberMapping

@implementation BlockNumberMapping

@dynamic headerhash;
@dynamic prevHeaderhash;

typedef struct BlockNumberMapping__storage_ {
  uint32_t _has_storage_[1];
  NSData *headerhash;
  NSData *prevHeaderhash;
} BlockNumberMapping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headerhash",
        .dataTypeSpecific.className = NULL,
        .number = BlockNumberMapping_FieldNumber_Headerhash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockNumberMapping__storage_, headerhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "prevHeaderhash",
        .dataTypeSpecific.className = NULL,
        .number = BlockNumberMapping_FieldNumber_PrevHeaderhash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockNumberMapping__storage_, prevHeaderhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockNumberMapping class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockNumberMapping__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StateLoader

@implementation StateLoader

@dynamic addressesArray, addressesArray_Count;
@dynamic tokenTxhashArray, tokenTxhashArray_Count;
@dynamic txhashArray, txhashArray_Count;
@dynamic totalCoinSupply;

typedef struct StateLoader__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSMutableArray *tokenTxhashArray;
  NSMutableArray *txhashArray;
  uint64_t totalCoinSupply;
} StateLoader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = StateLoader_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StateLoader__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tokenTxhashArray",
        .dataTypeSpecific.className = NULL,
        .number = StateLoader_FieldNumber_TokenTxhashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StateLoader__storage_, tokenTxhashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "txhashArray",
        .dataTypeSpecific.className = NULL,
        .number = StateLoader_FieldNumber_TxhashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StateLoader__storage_, txhashArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "totalCoinSupply",
        .dataTypeSpecific.className = NULL,
        .number = StateLoader_FieldNumber_TotalCoinSupply,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StateLoader__storage_, totalCoinSupply),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StateLoader class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StateLoader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StateObjects

@implementation StateObjects

@dynamic stateLoadersArray, stateLoadersArray_Count;

typedef struct StateObjects__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *stateLoadersArray;
} StateObjects__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stateLoadersArray",
        .dataTypeSpecific.className = NULL,
        .number = StateObjects_FieldNumber_StateLoadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StateObjects__storage_, stateLoadersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StateObjects class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StateObjects__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LRUStateCache

@implementation LRUStateCache


typedef struct LRUStateCache__storage_ {
  uint32_t _has_storage_[1];
} LRUStateCache__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LRUStateCache class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LRUStateCache__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerStat

@implementation PeerStat

@dynamic peerIp;
@dynamic port;
@dynamic hasNodeChainState, nodeChainState;

typedef struct PeerStat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  NSData *peerIp;
  NodeChainState *nodeChainState;
} PeerStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerIp",
        .dataTypeSpecific.className = NULL,
        .number = PeerStat_FieldNumber_PeerIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerStat__storage_, peerIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = PeerStat_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerStat__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nodeChainState",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeChainState),
        .number = PeerStat_FieldNumber_NodeChainState,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerStat__storage_, nodeChainState),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerStat class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeChainState

@implementation NodeChainState

@dynamic blockNumber;
@dynamic headerHash;
@dynamic cumulativeDifficulty;
@dynamic timestamp;

typedef struct NodeChainState__storage_ {
  uint32_t _has_storage_[1];
  NSData *headerHash;
  NSData *cumulativeDifficulty;
  uint64_t blockNumber;
  uint64_t timestamp;
} NodeChainState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "headerHash",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_HeaderHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, headerHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cumulativeDifficulty",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_CumulativeDifficulty,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, cumulativeDifficulty),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = NodeChainState_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeChainState__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeChainState class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeChainState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeHeaderHash

@implementation NodeHeaderHash

@dynamic blockNumber;
@dynamic headerhashesArray, headerhashesArray_Count;

typedef struct NodeHeaderHash__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *headerhashesArray;
  uint64_t blockNumber;
} NodeHeaderHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = NodeHeaderHash_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeHeaderHash__storage_, blockNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "headerhashesArray",
        .dataTypeSpecific.className = NULL,
        .number = NodeHeaderHash_FieldNumber_HeaderhashesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeHeaderHash__storage_, headerhashesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeHeaderHash class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeHeaderHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - P2PAcknowledgement

@implementation P2PAcknowledgement

@dynamic bytesProcessed;

typedef struct P2PAcknowledgement__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bytesProcessed;
} P2PAcknowledgement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bytesProcessed",
        .dataTypeSpecific.className = NULL,
        .number = P2PAcknowledgement_FieldNumber_BytesProcessed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(P2PAcknowledgement__storage_, bytesProcessed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[P2PAcknowledgement class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(P2PAcknowledgement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PeerInfo

@implementation PeerInfo

@dynamic peerIp;
@dynamic port;
@dynamic bannedTimestamp;
@dynamic credibility;
@dynamic lastConnectionsTimestampArray, lastConnectionsTimestampArray_Count;

typedef struct PeerInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  uint32_t bannedTimestamp;
  uint32_t credibility;
  NSData *peerIp;
  GPBUInt32Array *lastConnectionsTimestampArray;
} PeerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerIp",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_PeerIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, peerIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bannedTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_BannedTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, bannedTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "credibility",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_Credibility,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, credibility),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastConnectionsTimestampArray",
        .dataTypeSpecific.className = NULL,
        .number = PeerInfo_FieldNumber_LastConnectionsTimestampArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PeerInfo__storage_, lastConnectionsTimestampArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PeerInfo class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PeerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Peers

@implementation Peers

@dynamic peerInfoListArray, peerInfoListArray_Count;

typedef struct Peers__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peerInfoListArray;
} Peers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerInfo),
        .number = Peers_FieldNumber_PeerInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Peers__storage_, peerInfoListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Peers class]
                                     rootClass:[QrlRoot class]
                                          file:QrlRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Peers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
